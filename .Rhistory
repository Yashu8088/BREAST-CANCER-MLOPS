numbers <- as.numeric(unlist(strsplit(readline(prompt = "Enter numbers separated by spaces: "), " ")))
numbers <- c(5, 10, 3, 8, 2)
# Find maximum and minimum
max_num <- max(numbers)
min_num <- min(numbers)
# Print the results
cat("Maximum:", max_num, "\n")
cat("Minimum:", min_num, "\n")
# Input numbers
numbers <- c(5, 10, 3, 8, 2)
# Find maximum and minimum
max_num <- max(numbers)
min_num <- min(numbers)
# Print the results
cat("Maximum:", max_num, "\n")
cat("Minimum:", min_num, "\n")
N
# Input a year
year <- as.integer(readline(prompt = "Enter a year: "))
# Check for leap year
if ((year %% 4 == 0 && year %% 100 != 0) || (year %% 400 == 0)) {
cat(year, "is a leap year.\n")
} else {
cat(year, "is not a leap year.\n")
}
# Input a year
year <- as.integer(readline(prompt = "Enter a year: "))
# Check for leap year
if ((year %% 4 == 0 && year %% 100 != 0) || (year %% 400 == 0)) {
cat(year, "is a leap year.\n")
} else {
cat(year, "is not a leap year.\n")
}
# Input a year
year <- as.integer(readline(prompt = "Enter a year: "))
if ((year %% 4 == 0 && year %% 100 != 0) || (year %% 400 == 0)) {
cat(year, "is a leap year.\n")
} else {
cat(year, "is not a leap year.\n")
}
# 1. Mathematical operations
x <- 5
y <- 10
cat("Sum:", x + y, "\n")         # Addition
cat("Product:", x * y, "\n")     # Multiplication
cat("Mean:", mean(c(x, y)), "\n")  # Mean of x and y
# 2. String manipulation
text <- "Hello, World!"
cat("Uppercase:", toupper(text), "\n")  # Convert to uppercase
cat("Length of string:", nchar(text), "\n")  # Length of string
# 3. Data manipulation
vec <- c(2, 4, 6, 8)
cat("Max value in vector:", max(vec), "\n")  # Maximum value in the vector
cat("Sum of vector:", sum(vec), "\n")        # Sum of all elements in the vector
# 4. Date function
cat("Current date:", Sys.Date(), "\n")  # Current date
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
# Calculate and print the square
cat("The square of", num, "is", num^2, "\n")
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
cat("The square of", num, "is", num^2, "\n")
5
cat("The square of", num, "is", num^2, "\n")
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
# Calculate and print the square
cat("The square of", num, "is", num^2, "\n")
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
cat("The square of", num, "is", num^2, "\n")
# Install and load the plotly package (if not installed)
# install.packages("plotly")
library(plotly)
# Create sample data for a 3D plot
x <- seq(-5, 5, length.out = 50)
y <- seq(-5, 5, length.out = 50)
z <- outer(x, y, function(x, y) {sin(sqrt(x^2 + y^2))})
# Create 3D surface plot
fig <- plot_ly(x = x, y = y, z = z, type = "surface")
# Add title and labels
fig <- fig %>%
layout(
title = "3D Surface Plot of sin(sqrt(x^2 + y^2))",
scene = list(
xaxis = list(title = "X Axis"),
yaxis = list(title = "Y Axis"),
zaxis = list(title = "Z Axis")
)
)
# Show the plot
fig
# Install and load the scatterplot3d package (if not installed)
# install.packages("scatterplot3d")
library(scatterplot3d)
# Install and load the scatterplot3d package (if not installed)
# install.packages("scatterplot3d")
library(scatterplot3d)
# Create random data for 3D plotting
set.seed(123)
x <- rnorm(100)
y <- rnorm(100)
z <- rnorm(100)
# Create a simple 3D scatter plot
scatterplot3d(x, y, z, main="Simple 3D Scatter Plot", xlab="X Axis", ylab="Y Axis", zlab="Z Axis")
import pandas as pd
reticulate::repl_python()
# Define the module (as an environment)
factorial_module <- new.env()
# Recursive function to calculate factorial
factorial_module$calculate_factorial <- function(n) {
if (n == 0) {
return(1)
} else {
return(n * factorial_module$calculate_factorial(n - 1))
}
}
# Test the function
num <- 5
result <- factorial_module$calculate_factorial(num)
cat("The factorial of", num, "is:", result, "\n")
# Install and load the scatterplot3d package (if not installed)
# install.packages("scatterplot3d")
library(scatterplot3d)
# Create random data for 3D plotting
set.seed(123)
x <- rnorm(100)
y <- rnorm(100)
z <- rnorm(100)
# Create a simple 3D scatter plot
scatterplot3d(x, y, z, main="Simple 3D Scatter Plot", xlab="X Axis", ylab="Y Axis", zlab="Z Axis")
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
5# Calculate and print the square
cat("The square of", num, "is", num^2, "\n")
# Input number
num <- as.numeric(readline(prompt = "Enter a number: "))
# Calculate and print the square
cat("The square of", num, "is", num^2, "\n")
text <- "Hello, World!"
cat("Uppercase:", toupper(text), "\n")  # Convert to uppercase
cat("Lowercase:",tolower(text),"\n")
cat("Length of string:", nchar(text), "\n")  # Length of string
data
utils:::menuInstallLocal()
installed.packages()]
installed.packages()
installed_packages<-installed.packages()
installed_packages_names<-installed_packages{,"packages"]
installed_packages_names<-installed_packages{,"packages"}
data(packages="datasets")
data(packages="dataset")
q()
q()
path<-"D:\alliance\2nd sem\DS using oops\housing.csv"
path<-"D:/alliance/2nd sem/DS using oops/housing.csv"
path<-"D:/alliance/2nd sem/DS using oops/housing.csv"
content<-read.csv(path)
print(content)
import pandas as pd
import pandas
import pandas as pd
# Load necessary library
library(ggplot2)
# Load the dataset
file_path <- "D:/alliance/2nd sem/DS using oops/housing.csv"# Update with the correct file path if needed
df <- read.csv(file_path)
# Scatter plot of RM vs. MEDV
ggplot(df, aes(x = RM, y = MEDV)) +
geom_point(color = "blue", alpha = 0.5) +
labs(title = "Scatter Plot of RM vs. MEDV",
x = "Average Number of Rooms per Dwelling (RM)",
y = "Median Value of Homes (MEDV)") +
theme_minimal()
library(ggplot2)
plot(content$RM,content$LSTAT)
name(content)
library(ggplot2)
plot(content$RM,content$LSTAT)
name(content)
Load necessary library
plot(content$RM,content$LSTAT)
name(content)
plot(content$RM,content$LSTAT)
names(content)
cor(content$RM,content$LSTAT)
#crateing a dataframe
student<-list(
names=c('padmaja','muskaan','vishal','navya'),
ages=c(23,22,22,21),
scores=c(85,90,78,88)
)
print("student list:")
print("student")
averge_score<-mean(students$scores)
#crateing a dataframe
student<-list(
names=c('padmaja','muskaan','vishal','navya'),
ages=c(23,22,22,21),
scores=c(85,90,78,88)
)
print("student list:")
print("student")
averge_score<-mean(student$scores)
# Load the necessary library
library(dplyr)
# Create a DataFrame with student details
students <- data.frame(
Name = c("Alice", "Bob", "Charlie", "David", "Eva"),
Age = c(20, 21, 19, 22, 20),
Score = c(95, 82, 88, 76, 90),
Passed = c(TRUE, FALSE, TRUE, FALSE, TRUE)
)
# Print the DataFrame
print("Student Details DataFrame:")
print(students)
# Provide summary statistics
print("Summary Statistics:")
summary(students)
# Filter students who scored above 85
students_above_85 <- students %>% filter(Score > 85)
print("Students who scored above 85:")
print(students_above_85)
# Sort students by their Score in descending order
sorted_students <- students %>% arrange(desc(Score))
print("Students sorted by Score (descending):")
print(sorted_students)
# Add a new column "Grade" based on Score
students$Grade <- cut(students$Score,
breaks = c(0, 60, 70, 80, 90, 100),
labels = c("F", "D", "C", "B", "A"),
right = FALSE)
print("DataFrame with Grade added:")
print(students)
# Calculate and print the average score
average_score <- mean(students$Score)
print(paste("Average Score:", average_score))
# Load the necessary library
library(dplyr)
# Create a DataFrame with student details
students <- data.frame(
Name = c("Alice", "Bob", "Charlie", "David", "Eva"),
Age = c(20, 21, 19, 22, 20),
Score = c(95, 82, 88, 76, 90),
Passed = c(TRUE, FALSE, TRUE, FALSE, TRUE)
)
# Print the DataFrame
print("Student Details DataFrame:")
print(students)
# Provide summary statistics
print("Summary Statistics:")
summary(students)
# Filter students who scored above 85
students_above_85 <- students %>% filter(Score > 85)
print("Students who scored above 85:")
print(students_above_85)
# Sort students by their Score in descending order
sorted_students <- students %>% arrange(desc(Score))
print("Students sorted by Score (descending):")
print(sorted_students)
# Add a new column "Grade" based on Score
students$Grade <- cut(students$Score,
breaks = c(0, 60, 70, 80, 90, 100),
labels = c("F", "D", "C", "B", "A"),
right = FALSE)
print("DataFrame with Grade added:")
print(students)
# Calculate and print the average score
average_score <- mean(students$Score)
print(paste("Average Score:", average_score))
#boxplot to visualize outliers
boxplot(data$hp,main="Horsepower Outliers",col="blue")
#boxplot to visualize outliers
boxplot(data$hp,main="Horsepower Outliers",col="blue")
data<-mtcars
head(data)
str(data)
summary(data)
data[sample(1:nrow(data),5),"mpg"]<-NA
sum(is.na(data))
#fill the missing values
data$mpg[is.na(data$mpg)]<-mean(data$mpg,na.rm = TRUE)
#compute mean for all numeric columns
numeric_means<-sapply(data[,sapply(data,is.numeric)],mean,na.rm=TRUE)
print(numeric_means)
#boxplot to visualize outliers
boxplot(data$hp,main="Horsepower Outliers",col="blue")
#IQR method to removw outlier in hp
Q1<-quantile(data$hp,0.25)
Q3<-quantile(data$hp,0.75)
IQR<-Q3-Q1
#Filter data within the range
data<-[data$hp>(Q1-1.5*IQR)&data$hp<(Q3+1.5*IQR),]
Head(data,5)
Head(data,5)
data<-[data$hp>(Q1-1.5*IQR)&data$hp<(Q3+1.5*IQR),]
data<-[data$hp>(Q1-1.5*IQR)&data$hp<(Q3+1.5*IQR),]
#Filter data within the range
data<-data[data$hp>(Q1-1.5*IQR)&data$hp<(Q3+1.5*IQR),]
head(data,5)
print(head(data_scaled))
#z-score Normalization
data_scaled<-as.data.frame(scale(mtcars))
print(head(data_scaled))
#no need to encode as the columns are in numeric form
#create a new feature:power -to-weight ratio
data$power_to_weight<-data$hp/data$wt
#categorize mpg into high and low eifficiency
data$mpg_category<-ifelse(data$mpg>mean(data$mpg),"High","Low")
data$mpg_category<-as.factor(data$mpg_category)
data<-mtcars
head(data)
summary(data)
data[sample(1:nrow(data),5),"mpg"]<-NA
sum(is.na(data))
#fill the missing values
data$mpg[is.na(data$mpg)]<-mean(data$mpg,na.rm = TRUE)
#compute mean for all numeric columns
numeric_means<-sapply(data[,sapply(data,is.numeric)],mean,na.rm=TRUE)
print(numeric_means)
#boxplot to visualize outliers
boxplot(data$hp,main="Horsepower Outliers",col="blue")
#IQR method to removw outlier in hp
Q1<-quantile(data$hp,0.25)
Q3<-quantile(data$hp,0.75)
IQR<-Q3-Q1
#Filter data within the range
data<-data[data$hp>(Q1-1.5*IQR)&data$hp<(Q3+1.5*IQR),]
head(data,5)
#z-score Normalization
data_scaled<-as.data.frame(scale(mtcars))
print(head(data_scaled))
#no need to encode as the columns are in numeric form
#create a new feature:power -to-weight ratio
data$power_to_weight<-data$hp/data$wt
#categorize mpg into high and low eifficiency
data$mpg_category<-ifelse(data$mpg>mean(data$mpg),"High","Low")
data$mpg_category<-as.factor(data$mpg_category)
#split into traning (70) and testing(30) sets
trainIndex<-createDatePartition(data$mpg,p=0.7,list=FALSE)
install.packages("caret")
library(caret)
#split into traning (70) and testing(30) sets
trainIndex<-createDatePartition(data$mpg,p=0.7,list=FALSE)
trainData<-data[trainIndex,]
testData<-data[-trainIndex,]
#split into traning (70) and testing(30) sets
trainIndex<-createDataPartition(data$mpg,p=0.7,list=FALSE)
trainData<-data[trainIndex,]
testData<-data[-trainIndex,]
#train the linear regression model
lm_model<-train(mpg~.,data=trainData,method="lm")
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lim_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
nstall.packages("caret")
#train the linear regression model
lm_model<-train(mpg~.,data=trainData,method="lm")
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lim_predictions-testData$mpg)^2)
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lim_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lm_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
#train the linear regression model
lm_model<-train(mpg~.,data=trainData,method="lm")
Summary(lm_model)
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lm_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lm_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
set.seed(40)
set.seed(40)
#train the linear regression model
lm_model<-train(mpg~.,data=trainData,method="lm")
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lm_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
set.seed(40)
#split into traning (70) and testing(30) sets
trainIndex<-createDataPartition(data$mpg,p=0.7,list=FALSE)
trainData<-data[trainIndex,]
testData<-data[-trainIndex,]
#train the linear regression model
lm_model<-train(mpg~.,data=trainData,method="lm")
Summary(lm_model)
#predict one test data
lm_predictions<-predict(lm_model,testData)
#evaluate model performance
lm_mse<-mean((lm_predictions-testData$mpg)^2)
print(paste("Linear Regression MSE:",lm_mse))
head(data)
Library(randomFroest)
#predict on test data
rf_predictions
library(randomForest)
#random forest
rf_model<-train(mpg~.,data=trainData,method='rf',ntree=100)
summary(rf_model)
#predict omn test data
rf_predictions<-predict(rf_model,testData)
#confusion matrix
confusionMatrix(rf_predictions,testData$am)
#decision Tree-Classification(am-manual/automatic)
dt_model<-train(am~.,data=trainData,method="rpart")
Summary(dt_model)
#Predict on test data
dt_prediction<-predict(dt_model,testData)
#confusion matrix
confusionMatrix(dt_prediction,testData$am)
install.packages("randomForest")
# Ensure the caret package is loaded
library(caret)
# Convert both predictions and actual values to factors with the same levels
rf_predictions <- factor(rf_predictions, levels = levels(factor(testData$am)))
testData$am <- factor(testData$am)  # Ensure actual values are factors
# Generate confusion matrix
conf_matrix <- confusionMatrix(rf_predictions, testData$am)
print(conf_matrix)
# Load required packages
library(caret)
library(rpart)         # For decision tree model
library(rpart.plot)    # For visualizing the decision tree
# Train a Decision Tree model using the correct method "rpart"
dt_model <- train(am ~ ., data = trainData, method = "rpart")
# Print model summary
print(dt_model)
# Predict on test data
dt_predictions <- predict(dt_model, testData)
# Ensure predictions and actual values are factors
dt_predictions <- factor(dt_predictions, levels = levels(factor(testData$am)))
testData$am <- factor(testData$am)
# Generate confusion matrix
conf_matrix <- confusionMatrix(dt_predictions, testData$am)
print(conf_matrix)
Summary(svm_model)
#predict on test data
svm_predictions<-predict(svm_model,testData)
#confusion matrix
confusionMatrix(svm_predictions,testData$am)
Summary(svm_model)
library(ggplot2)
ggplot(mpg,aes(x=displ,y=hwy))+geom_point()+labs(title="EngineDisplacement vs Highway MPG",
x="Engine Displacement(L)",y="Highway MPG")+
theme_minimal()
#Boxplot
ggplot(mtcars,aes(x=factor(cyl),y=mpg,fill=factor(cyl)))+geom_boxplot(outlier.colour = "red",outlier.shape = 16,outlier.size=2)+
labs(title="Distribution of MPG by Cylinder Count",
x="Number of Cylinders",
y="Miles Per Gallon(MPG)",
fill="Cylinders")+
theme_minimal()
library(datasets)
library(ggplot2)
data("airquality")
head(airquality)
summary(airquality)
clean_data <- na.omit(airquality)
model <- lm(Ozone ~ Solar.R + Wind + Temp + Month + Day, data = clean_data)
summary(model)
predicted_ozone <- predict(model, newdata = clean_data)
results <- data.frame(Actual = clean_data$Ozone, Predicted = predicted_ozone)
head(results)
ggplot(results, aes(x = Actual, y = Predicted)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
labs(title = "Actual vs Predicted Ozone", x = "Actual Ozone", y = "Predicted Ozone") +
theme_minimal()
list.files()
setwd("D:/alliance/4thsem/mlops/breast_cancer_mlflow")
list.files()
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
setwd("D:/alliance/4thsem/mlops/breast_cancer_mlflow")
list.files()
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
setwd("D:/alliance/4thsem/mlops/breast_cancer_mlflow")
data <- read.csv("breast_cancer.csv")
colnames(data)
setwd("D:/alliance/4thsem/mlops/breast_cancer_mlflow")
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
setwd("D:/alliance/4thsem/mlops/breast_cancer_mlflow")
source("D:/alliance/4thsem/mlops/breast_cancer_mlflow/breast_cancer_mlflow.R")
